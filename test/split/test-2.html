<h2>THE NEW PRIORITIES</h2>
<p>The big difference is the jump from traditional operating systems. On traditional systems like Mac OS X and Windows, the fundamental idea behind a process is that once running, it will stay running until the process itself quits. On desktop systems like the Mac and Windows, that typically means that the user tells the app to quit (or, in Windows vernacular, &ldquo;exit&rdquo; &mdash; same thing). The user can do something like invoke the system-wide &ldquo;Shut Down&rdquo; or &ldquo;Log Out&rdquo; command, and then the system will send a quit event to all running applications &mdash; but that&rsquo;s still managed by the user. It&rsquo;s a way for the user to tell all apps to quit at once. And even then, it&rsquo;s still up to each app to do whatever it wants on its way to quitting. It&rsquo;s a suggestion to quit. All Mac users are familiar with the &ldquo;Hey, this app can&rsquo;t quit immediately, you&rsquo;ve got documents open with unsaved changes&rdquo; dialog box.</p>
<p>In this traditional model, if an app isn&rsquo;t ready to quit, it can refuse to. Or, if it needs to run through a lengthy minute-long save operation upon quitting, it can do so. Yes, you can force-quit apps in any such operating system, but when you do, it&rsquo;s more akin to forcing the app to crash. When you force-quit an app on the Mac, it&rsquo;s abnormal.</p>
<p>It&rsquo;s also the case that OSes such as Mac OS X, Windows, and desktop Linux use swap &mdash; when physical RAM runs low, the operating system will start paging chunks of memory to storage on disk. Relative to each other, RAM is fast and expensive; storage is slow but cheap. The tradeoff with swap is that you get to pretend your machine has more RAM than it really does, but it&rsquo;s far slower than using only real RAM.</p>
<p>Mac OS X will never, in practical use, &ldquo;run out of memory&rdquo;. If you keep opening more and more applications and documents, it will slow down, using more and more swap. Eventually it will slow down to the point where it&rsquo;s unusable. But it will not report running out of memory. The deal is: you launch an app, it&rsquo;ll run, and it&rsquo;ll stay running until it (the app) is ready to quit, memory (and responsiveness) be damned.</p>
<p>The new model, exemplified by mobile systems like the iPhone and Android, is that apps are not quit manually by the user. You, the user, just open them, and the system takes care of managing them after that. You don&rsquo;t even have to understand the concept of quitting an application &mdash; in fact, you&rsquo;re better off not worrying about it. There is no swap, so when memory runs low, something has to give. If the app is frontmost, it is running. If it is not frontmost, it might continue to run in limited fashion, but the system might pull the plug on it at any moment to reclaim its memory.</p>
<p>The original Mac OS &mdash; the one from the 1980s &mdash; also lacked swap. When it ran low on memory, it would simply refuse to launch more applications. You&rsquo;d get a dialog box telling you there was not enough free memory to launch the app, and that you, the user, needed to quit other running applications to free additional memory.</p>
<p>The new way is to rethink the fundamental deal for processes. In the old model, processes that have already been launched get priority &mdash; once running, they stay running. In the new model, the user&rsquo;s intentions get priority. You press the home button, you&rsquo;re going to see the home screen in a moment, whether the app that was running was ready to be closed or not. If you want to open another app, it&rsquo;s going to open immediately, even if the system has to pull the plug on an app in the background to free enough RAM.</p>
<p>On iPhone and Android, apps don&rsquo;t decide when to quit. They must be ready to quit on short notice at any time. In current versions of iPhone OS, third-party apps are quit when the user hits the home button. The user is free to hit the home button at any time. The system effectively tells the frontmost app, &ldquo;OK, you&rsquo;re done&rdquo; and the app has a few moments to save state or clean up. But after those moments, if the app is still busy, too bad &mdash; the system kills it.</p>
<p>And even with iPhone OS 4&rsquo;s &ldquo;multitasking&rdquo;, apps must be ready to quit at any time on a moment&rsquo;s notice. When the system runs low on free RAM, it will start quitting apps that are open in the background, and when it does so, it will not wait around for them to &ldquo;do something&rdquo;.2 The same is true for Android. This is a fundamental change to how multitasking systems work. It works because the apps for these systems have been written from the ground up to embrace this model.</p>
<p>It may well be that this model is temporary &mdash; that it&rsquo;s a factor of the relatively restrictive amounts of RAM in these devices. At some point not too many years from now, we&rsquo;ll have iPhones and iPads and Android devices with gigabytes of RAM, rather than megabytes, and at that point, we may well return to a more persistent model of multitasking. But in the short term, this is not going to change. And no matter how much RAM future devices contain, it&rsquo;s never again going to be acceptable to make users wait before launching or switching contexts.</p>
<p>In the traditional model, the primary priority is keeping everything open. In this new model, the primary priority is that the system must always be responsive to the user. There is no waiting for swap. There are no slowdowns caused by background processes using significant amounts of CPU time.</p>
<p>You know what iPhone OS is missing that Mac OS X has? The SPOD.</p>